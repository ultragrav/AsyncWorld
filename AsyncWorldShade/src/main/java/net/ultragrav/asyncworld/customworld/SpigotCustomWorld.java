package net.ultragrav.asyncworld.customworld;

import net.ultragrav.asyncworld.AsyncChunk;
import net.ultragrav.asyncworld.AsyncWorld;
import net.ultragrav.asyncworld.SpigotAsyncWorld;
import net.ultragrav.asyncworld.relighter.NMSRelighter;
import net.ultragrav.asyncworld.relighter.Relighter;
import org.bukkit.Bukkit;
import org.bukkit.World;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

public class SpigotCustomWorld extends CustomWorld {

    private CustomWorldHandler worldHandler;

    private static int sV;

    private static String SERVER_VERSION = null;

    public static String getServerVersion() {
        if (SERVER_VERSION == null) {
            String pathName = Bukkit.getServer().getClass().getName();
            String[] parts = pathName.split("\\.");
            SERVER_VERSION = parts[3];
        }
        if (SERVER_VERSION.startsWith("v1_12"))
            sV = 1;
        else
            sV = -1;
        return SERVER_VERSION;
    }

    public static int getServerVersionInt() {
        return sV;
    }

    private SpigotCustomWorldAsyncWorld asyncWorld;

    private final Relighter relighter;

    public ExecutorService service = Executors.newSingleThreadExecutor();

    private final AtomicBoolean startedCreation = new AtomicBoolean(false);

    private final String name;

    private final Plugin plugin;

    private final int sizeChunksX;
    private final int sizeChunksZ;

    /**
     * Create a custom world with a certain size that is generated by a function passed to the
     * function #create that consumes an AsyncWorld instance. #create may, and it is encouraged to, be called
     * asynchronously. #create will almost always take at least 50ms to execute due to scheduling delays, as it
     * does need some operations to happen synchronously, such as calling WorldInitEvent and WorldLoadEvent.
     *
     * @param plugin
     * @param name
     * @param sizeChunksX
     * @param sizeChunksZ
     */
    public SpigotCustomWorld(Plugin plugin, String name, int sizeChunksX, int sizeChunksZ) {
        getServerVersion(); //Make sure it's not null
        this.name = name;
        this.plugin = plugin;
        this.sizeChunksX = sizeChunksX;
        this.sizeChunksZ = sizeChunksZ;
        this.asyncWorld = new SpigotCustomWorldAsyncWorld(this, this.plugin);
        this.relighter = new NMSRelighter(this.plugin);
    }

    /**
     * Create the world
     *
     * @param generator The function that will generate the world's contents
     */
    @Override
    public void create(Consumer<CustomWorldAsyncWorld> generator) {

        if (!startedCreation.compareAndSet(false, true))
            throw new RuntimeException("World already created!");

        //Create world server
        if (worldHandler == null)
            createWorldHandler();
        if (!worldHandler.isWorldCreated())
            worldHandler.createWorld(this, name);

        //Generate world
        generator.accept(asyncWorld);

        //Set chunks' sections (write to world)
        ForkJoinPool pool = new ForkJoinPool(Runtime.getRuntime().availableProcessors()); //Multi-threaded
        List<CustomWorldAsyncChunk<?>> chunks = asyncWorld.getChunkMap().getCachedCopy(); //DO NOT CLEAR THE CHUNK MAP because they're 1 time creation chunks
        //that hold the nms chunks
        chunks.forEach((c) -> pool.submit(() -> worldHandler.finishChunk(c))); //Submit tasks
        while (!pool.isQuiescent()) pool.awaitQuiescence(1, TimeUnit.SECONDS); //Wait for tasks to complete


        //Add to world list (Must be sync)
        if (!Bukkit.isPrimaryThread()) {
            CompletableFuture<Void> future = new CompletableFuture<>();
            new BukkitRunnable() {
                @Override
                public void run() {
                    worldHandler.addToWorldList();
                    future.complete(null);
                }
            }.runTask(plugin);
            future.join();
        } else {
            worldHandler.addToWorldList();
        }

        queueSkyRelight(chunks); //Relight chunks
    }

    private void queueSkyRelight(List<CustomWorldAsyncChunk<?>> chunks) {
        Map<AsyncChunk, Integer> masks = new HashMap<>();
        for (AsyncChunk chunk : chunks) {
            int editedSections = chunk.getEditedSections();
            for (int i = 0; i < 16; i++) {
                boolean a = ((editedSections >>> i) & 1) != 0;
                if (a && i != 0) {
                    editedSections |= 1 << (i - 1);
                }
                if (a && i != 15) {
                    editedSections |= 1 << (i++ + 1);
                }
            }
            masks.put(chunk, editedSections);
        }

        //Must use a spigot async world because if the relighter creates any new async chunks, it would be bad if that chunk needed
        //finish() to be called because it could be loaded -> it would stall the main thread
        SpigotAsyncWorld spigotAsyncWorld = new SpigotAsyncWorld(getBukkitWorld());

        //Queue
        chunks.forEach(c -> {
            int mask = masks.get(c);

            AsyncChunk spigotAsyncChunk = spigotAsyncWorld.getChunk(c.getLoc().getX(), c.getLoc().getZ());

            Relighter.RelightAction[] actions = new Relighter.RelightAction[16];
            for (int i = 0; i < 16; i++) {
                if ((mask >>> i & 1) == 1) {
                    actions[i] = Relighter.RelightAction.ACTION_RELIGHT;
                } else {
                    actions[i] = Relighter.RelightAction.ACTION_SKIP_AIR;
                }
            }
            relighter.queueSkyRelight(spigotAsyncChunk, actions);
        });
    }

    /**
     * Calls create in a separate thread
     */
    public Future<Void> createAsync(Consumer<CustomWorldAsyncWorld> generator) {
        return service.submit(() -> {
            create(generator);
            return null;
        });
    }

    private void createWorldHandler() {
        if (sV == 1) {
            this.worldHandler = new CustomWorldHandler1_12();
        } else {
            throw new RuntimeException("Server version not supported!");
        }
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public World getBukkitWorld() {
        return this.worldHandler.getBukkitWorld();
    }

    @Override
    public CustomWorldAsyncChunk<?> getChunk(int cx, int cz) {
        if (cx < 0 || cz < 0 || cx > sizeChunksX || cz > sizeChunksZ) {
            return null;
        }
        if (asyncWorld.getChunkMap().get(cx, cz) == null)
            return null;
        CustomWorldAsyncChunk<?> asyncChunk = asyncWorld.getChunk(cx, cz);
        asyncChunk.awaitFinish();
        return asyncChunk;
    }

    @Override
    public Plugin getPlugin() {
        return this.plugin;
    }

    /**
     * Attempt to unload the world, there must be 0 players currently inside of the world, if there are not 0, you must
     * teleport them out before calling this method
     */
    @Override
    public void unload() {
        this.asyncWorld = new SpigotCustomWorldAsyncWorld(this, this.plugin); //In case something has a reference to the world server, and therefore this object,
        //It's a good idea to dereference the async world and therefore all the chunks inside of it
        if (this.getBukkitWorld() == null)
            return;
        Bukkit.unloadWorld(this.getBukkitWorld(), false);
    }
}
