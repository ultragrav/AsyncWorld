package net.ultragrav.asyncworld.customworld;

import net.ultragrav.asyncworld.AsyncWorld;
import org.bukkit.Bukkit;
import org.bukkit.World;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

public class SpigotCustomWorld extends CustomWorld {

    private CustomWorldHandler1_12 worldHandler;

    private static int sV;

    private static String SERVER_VERSION = null;

    public static String getServerVersion() {
        if (SERVER_VERSION == null) {
            String pathName = Bukkit.getServer().getClass().getName();
            String[] parts = pathName.split("\\.");
            SERVER_VERSION = parts[3];
        }
        if (SERVER_VERSION.startsWith("v1_12"))
            sV = 1;
        else
            sV = -1;
        return SERVER_VERSION;
    }

    public static int getServerVersionInt() {
        return sV;
    }

    private final SpigotCustomWorldAsyncWorld asyncWorld = new SpigotCustomWorldAsyncWorld();

    public ExecutorService service = Executors.newSingleThreadExecutor();

    private final AtomicBoolean startedCreation = new AtomicBoolean(false);

    private final String name;

    private final Plugin plugin;

    private final int sizeChunksX;
    private final int sizeChunksZ;

    /**
     * Create a custom world with a certain size that is generated by a function passed to the
     * function #create that consumes an AsyncWorld instance. #create may, and it is encouraged to, be called
     * asynchronously. #create will almost always take at least 50ms to execute due to scheduling delays, as it
     * does need some operations to happen synchronously, such as calling WorldInitEvent and WorldLoadEvent.
     * @param plugin
     * @param name
     * @param sizeChunksX
     * @param sizeChunksZ
     */
    public SpigotCustomWorld(Plugin plugin, String name, int sizeChunksX, int sizeChunksZ) {
        getServerVersion(); //Make sure it's not null
        this.name = name;
        this.plugin = plugin;
        this.sizeChunksX = sizeChunksX;
        this.sizeChunksZ = sizeChunksZ;
    }

    /**
     * Create the world
     * @param generator The function that will generate the world's contents
     */
    @Override
    public void create(Consumer<CustomWorldAsyncWorld> generator) {

        if (!startedCreation.compareAndSet(false, true))
            throw new RuntimeException("World already created!");

        //Create world server
        if (worldHandler == null)
            createWorldHandler();
        if (!worldHandler.isWorldCreated())
            worldHandler.createWorld(this, name);

        //Generate world
        generator.accept(asyncWorld);

        //Set chunks' sections (write to world)
        ForkJoinPool pool = new ForkJoinPool(Runtime.getRuntime().availableProcessors()); //Multi-threaded
        asyncWorld.getChunkMap().getCachedCopy().forEach((c) -> pool.submit(() -> worldHandler.finishChunk(c))); //Submit tasks
        while (!pool.isQuiescent()) pool.awaitQuiescence(1, TimeUnit.SECONDS); //Wait for tasks to complete

        //Add to world list (Must be sync)
        if(!Bukkit.isPrimaryThread()) {
            CompletableFuture<Void> future = new CompletableFuture<>();
            new BukkitRunnable() {
                @Override
                public void run() {
                    worldHandler.addToWorldList();
                    future.complete(null);
                }
            }.runTask(plugin);
            future.join();
        } else {
            worldHandler.addToWorldList();
        }
    }

    /**
     * Calls create in a separate thread
     */
    public Future<Void> createAsync(Consumer<CustomWorldAsyncWorld> generator) {
        return service.submit(() -> {
            create(generator);
            return null;
        });
    }

    private void createWorldHandler() {
        if (sV == 1) {
            this.worldHandler = new CustomWorldHandler1_12();
        } else {
            throw new RuntimeException("Server version not supported!");
        }
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public World getBukkitWorld() {
        return this.worldHandler.getBukkitWorld();
    }

    @Override
    public CustomWorldAsyncChunk<?> getChunk(int cx, int cz) {
        if (cx < 0 || cz < 0 || cx > sizeChunksX || cz > sizeChunksZ) {
            return null;
        }
        if (asyncWorld.getChunkMap().get(cx, cz) == null)
            return null;
        CustomWorldAsyncChunk<?> asyncChunk = asyncWorld.getChunk(cx, cz);
        asyncChunk.awaitFinish();
        return asyncChunk;
    }

    @Override
    public Plugin getPlugin() {
        return this.plugin;
    }

    /**
     * Attempt to unload the world, there must be 0 players currently inside of the world, if there are not 0, you must
     * teleport them out before calling this method
     */
    @Override
    public void unload() {
        if(this.getBukkitWorld() == null)
            return;
        Bukkit.unloadWorld(this.getBukkitWorld(), false);
    }
}
